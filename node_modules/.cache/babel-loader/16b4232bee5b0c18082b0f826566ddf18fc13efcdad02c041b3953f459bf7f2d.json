{"ast":null,"code":"/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = require('./addLengthGuard');\nvar chai = require('../../chai');\nvar flag = require('./flag');\nvar proxify = require('./proxify');\nvar transferFlags = require('./transferFlags');\n\n/**\n * ### .overwriteMethod(ctx, name, fn)\n *\n * Overwrites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @namespace Utils\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name],\n    _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n  if (_method && 'function' === typeof _method) _super = _method;\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n    if (result !== undefined) {\n      return result;\n    }\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  };\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};","map":{"version":3,"names":["addLengthGuard","require","chai","flag","proxify","transferFlags","module","exports","overwriteMethod","ctx","name","method","_method","_super","Error","overwritingMethodWrapper","origLockSsfi","result","apply","arguments","undefined","newAssertion","Assertion"],"sources":["C:/laragon/www/vue-projects/bookstore/node_modules/chai/lib/chai/utils/overwriteMethod.js"],"sourcesContent":["/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar addLengthGuard = require('./addLengthGuard');\nvar chai = require('../../chai');\nvar flag = require('./flag');\nvar proxify = require('./proxify');\nvar transferFlags = require('./transferFlags');\n\n/**\n * ### .overwriteMethod(ctx, name, fn)\n *\n * Overwrites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @namespace Utils\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function overwriteMethod(ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () {\n      throw new Error(name + ' is not a function');\n    };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  var overwritingMethodWrapper = function () {\n    // Setting the `ssfi` flag to `overwritingMethodWrapper` causes this\n    // function to be the starting point for removing implementation frames from\n    // the stack trace of a failed assertion.\n    //\n    // However, we only want to use this function as the starting point if the\n    // `lockSsfi` flag isn't set.\n    //\n    // If the `lockSsfi` flag is set, then either this assertion has been\n    // overwritten by another assertion, or this assertion is being invoked from\n    // inside of another assertion. In the first case, the `ssfi` flag has\n    // already been set by the overwriting assertion. In the second case, the\n    // `ssfi` flag has already been set by the outer assertion.\n    if (!flag(this, 'lockSsfi')) {\n      flag(this, 'ssfi', overwritingMethodWrapper);\n    }\n\n    // Setting the `lockSsfi` flag to `true` prevents the overwritten assertion\n    // from changing the `ssfi` flag. By this point, the `ssfi` flag is already\n    // set to the correct starting point for this assertion.\n    var origLockSsfi = flag(this, 'lockSsfi');\n    flag(this, 'lockSsfi', true);\n    var result = method(_super).apply(this, arguments);\n    flag(this, 'lockSsfi', origLockSsfi);\n\n    if (result !== undefined) {\n      return result;\n    }\n\n    var newAssertion = new chai.Assertion();\n    transferFlags(this, newAssertion);\n    return newAssertion;\n  }\n\n  addLengthGuard(overwritingMethodWrapper, name, false);\n  ctx[name] = proxify(overwritingMethodWrapper, name);\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,cAAc,GAAGC,OAAO,CAAC,kBAAkB,CAAC;AAChD,IAAIC,IAAI,GAAGD,OAAO,CAAC,YAAY,CAAC;AAChC,IAAIE,IAAI,GAAGF,OAAO,CAAC,QAAQ,CAAC;AAC5B,IAAIG,OAAO,GAAGH,OAAO,CAAC,WAAW,CAAC;AAClC,IAAII,aAAa,GAAGJ,OAAO,CAAC,iBAAiB,CAAC;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAK,MAAM,CAACC,OAAO,GAAG,SAASC,eAAeA,CAACC,GAAG,EAAEC,IAAI,EAAEC,MAAM,EAAE;EAC3D,IAAIC,OAAO,GAAGH,GAAG,CAACC,IAAI,CAAC;IACnBG,MAAM,GAAG,SAAAA,CAAA,EAAY;MACrB,MAAM,IAAIC,KAAK,CAACJ,IAAI,GAAG,oBAAoB,CAAC;IAC9C,CAAC;EAEH,IAAIE,OAAO,IAAI,UAAU,KAAK,OAAOA,OAAO,EAC1CC,MAAM,GAAGD,OAAO;EAElB,IAAIG,wBAAwB,GAAG,SAAAA,CAAA,EAAY;IACzC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAACZ,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,EAAE;MAC3BA,IAAI,CAAC,IAAI,EAAE,MAAM,EAAEY,wBAAwB,CAAC;IAC9C;;IAEA;IACA;IACA;IACA,IAAIC,YAAY,GAAGb,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC;IACzCA,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,IAAI,CAAC;IAC5B,IAAIc,MAAM,GAAGN,MAAM,CAACE,MAAM,CAAC,CAACK,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC;IAClDhB,IAAI,CAAC,IAAI,EAAE,UAAU,EAAEa,YAAY,CAAC;IAEpC,IAAIC,MAAM,KAAKG,SAAS,EAAE;MACxB,OAAOH,MAAM;IACf;IAEA,IAAII,YAAY,GAAG,IAAInB,IAAI,CAACoB,SAAS,CAAC,CAAC;IACvCjB,aAAa,CAAC,IAAI,EAAEgB,YAAY,CAAC;IACjC,OAAOA,YAAY;EACrB,CAAC;EAEDrB,cAAc,CAACe,wBAAwB,EAAEL,IAAI,EAAE,KAAK,CAAC;EACrDD,GAAG,CAACC,IAAI,CAAC,GAAGN,OAAO,CAACW,wBAAwB,EAAEL,IAAI,CAAC;AACrD,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}