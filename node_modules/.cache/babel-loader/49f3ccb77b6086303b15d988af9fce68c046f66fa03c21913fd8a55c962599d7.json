{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReactiveEffect = exports.ITERATE_KEY = exports.EffectScope = void 0;\nexports.computed = computed;\nexports.customRef = customRef;\nexports.deferredComputed = deferredComputed;\nexports.effect = effect;\nexports.effectScope = effectScope;\nexports.enableTracking = enableTracking;\nexports.getCurrentScope = getCurrentScope;\nexports.isProxy = isProxy;\nexports.isReactive = isReactive;\nexports.isReadonly = isReadonly;\nexports.isRef = isRef;\nexports.isShallow = isShallow;\nexports.markRaw = markRaw;\nexports.onScopeDispose = onScopeDispose;\nexports.pauseTracking = pauseTracking;\nexports.proxyRefs = proxyRefs;\nexports.reactive = reactive;\nexports.readonly = readonly;\nexports.ref = ref;\nexports.resetTracking = resetTracking;\nexports.shallowReactive = shallowReactive;\nexports.shallowReadonly = shallowReadonly;\nexports.shallowRef = shallowRef;\nexports.stop = stop;\nexports.toRaw = toRaw;\nexports.toRef = toRef;\nexports.toRefs = toRefs;\nexports.toValue = toValue;\nexports.track = track;\nexports.trigger = trigger;\nexports.triggerRef = triggerRef;\nexports.unref = unref;\nrequire(\"core-js/modules/es.array.push.js\");\nvar _shared = require(\"@vue/shared\");\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nexports.EffectScope = EffectScope;\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);\n  }\n}\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\nconst targetMap = /* @__PURE__ */new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nexports.ITERATE_KEY = ITERATE_KEY;\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nexports.ReactiveEffect = ReactiveEffect;\nfunction cleanupEffect(effect2) {\n  const {\n    deps\n  } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    (0, _shared.extend)(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? {\n      effect: activeEffect,\n      target,\n      type,\n      key\n    } : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (!!(process.env.NODE_ENV !== \"production\") && activeEffect.onTrack) {\n      activeEffect.onTrack((0, _shared.extend)({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && (0, _shared.isArray)(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!(0, _shared.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0, _shared.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if ((0, _shared.isIntegerKey)(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!(0, _shared.isArray)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if ((0, _shared.isMap)(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if ((0, _shared.isMap)(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  } : void 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = (0, _shared.isArray)(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (!!(process.env.NODE_ENV !== \"production\") && effect2.onTrigger) {\n      effect2.onTrigger((0, _shared.extend)({\n        effect: effect2\n      }, debuggerEventExtraInfo));\n    }\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\nconst isNonTrackableKeys = /* @__PURE__ */(0, _shared.makeMap)(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set( /* @__PURE__ */Object.getOwnPropertyNames(Symbol).filter(key => key !== \"arguments\" && key !== \"caller\").map(key => Symbol[key]).filter(_shared.isSymbol));\nconst get$1 = /* @__PURE__ */createGetter();\nconst shallowGet = /* @__PURE__ */createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = (0, _shared.isArray)(target);\n    if (!isReadonly2) {\n      if (targetIsArray && (0, _shared.hasOwn)(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if ((0, _shared.isSymbol)(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && (0, _shared.isIntegerKey)(key) ? res : res.value;\n    }\n    if ((0, _shared.isObject)(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /* @__PURE__ */createSetter();\nconst shallowSet = /* @__PURE__ */createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!(0, _shared.isArray)(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = (0, _shared.isArray)(target) && (0, _shared.isIntegerKey)(key) ? Number(key) < target.length : (0, _shared.hasOwn)(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if ((0, _shared.hasChanged)(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = (0, _shared.hasOwn)(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!(0, _shared.isSymbol)(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", (0, _shared.isArray)(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /* @__PURE__ */(0, _shared.extend)({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n});\nconst shallowReadonlyHandlers = /* @__PURE__ */(0, _shared.extend)({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\nconst toShallow = value => value;\nconst getProto = v => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const {\n    has: has2\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if ((0, _shared.hasChanged)(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has: has2,\n    get: get2\n  } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? (0, _shared.isMap)(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = (0, _shared.isMap)(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${(0, _shared.capitalize)(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations2, readonlyInstrumentations2, shallowInstrumentations2, shallowReadonlyInstrumentations2];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get((0, _shared.hasOwn)(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = (0, _shared.toRawType)(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);\n  }\n}\nconst reactiveMap = /* @__PURE__ */new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */new WeakMap();\nconst readonlyMap = /* @__PURE__ */new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap((0, _shared.toRawType)(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!(0, _shared.isObject)(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  (0, _shared.def)(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = value => (0, _shared.isObject)(value) ? reactive(value) : value;\nconst toReadonly = value => (0, _shared.isObject)(value) ? readonly(value) : value;\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      trackEffects(ref2.dep || (ref2.dep = createDep()), {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(dep, {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if ((0, _shared.hasChanged)(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return (0, _shared.isFunction)(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = (0, _shared.isArray)(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if ((0, _shared.isFunction)(source)) {\n    return new GetterRefImpl(source);\n  } else if ((0, _shared.isObject)(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = (0, _shared.isFunction)(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : _shared.NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\nconst tick = /* @__PURE__ */Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = fn => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(true\n            /* computedTrigger */);\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}","map":{"version":3,"names":["_shared","require","warn","msg","args","console","activeEffectScope","EffectScope","constructor","detached","_active","effects","cleanups","parent","index","scopes","push","active","run","fn","currentEffectScope","process","env","NODE_ENV","on","off","stop","fromParent","i","l","length","last","pop","exports","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","effect2","options","_effect","extend","lazy","runner","bind","trackStack","pauseTracking","enableTracking","resetTracking","track","target","type","key","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","shouldTrack2","has","add","onTrack","trigger","newValue","oldValue","oldTarget","values","isArray","newLength","Number","forEach","key2","isMap","isIntegerKey","triggerEffects","computed","triggerEffect","allowRecurse","onTrigger","getDepFromReactive","object","_a","isNonTrackableKeys","makeMap","builtInSymbols","Object","getOwnPropertyNames","filter","map","isSymbol","get$1","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","res","apply","hasOwnProperty","obj","isReadonly2","shallow","get2","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","hasOwn","Reflect","isRef","value","isObject","readonly","reactive","set$1","createSetter","shallowSet","set2","isReadonly","isShallow","hadKey","result","hasChanged","deleteProperty","has$1","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","has2","wrap","toReadonly","toReactive","call","size","proto","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","capitalize","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","iteratorMethods","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","toRawType","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","def","trackRefValue","ref2","triggerRefValue","newVal","r","__v_isRef","ref","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","triggerRef","unref","toValue","source","isFunction","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","ret","Array","propertyToRef","ObjectRefImpl","_object","_key","_defaultValue","val","GetterRefImpl","_getter","__v_isReadonly","toRef","defaultValue","arguments","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","NOOP","cRef","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","e","deferredComputed"],"sources":["C:/laragon/www/vue-projects/bookstore/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nconst createDep = (effects) => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit;\n    }\n  }\n};\nconst finalizeDepMarkers = (effect) => {\n  const { deps } = effect;\n  if (deps.length) {\n    let ptr = 0;\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      }\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    this.parent = void 0;\n    recordEffectScope(this, scope);\n  }\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n    let parent = activeEffect;\n    let lastShouldTrack = shouldTrack;\n    while (parent) {\n      if (parent === this) {\n        return;\n      }\n      parent = parent.parent;\n    }\n    try {\n      this.parent = activeEffect;\n      activeEffect = this;\n      shouldTrack = true;\n      trackOpBit = 1 << ++effectTrackDepth;\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this);\n      } else {\n        cleanupEffect(this);\n      }\n      return this.fn();\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this);\n      }\n      trackOpBit = 1 << --effectTrackDepth;\n      activeEffect = this.parent;\n      shouldTrack = lastShouldTrack;\n      this.parent = void 0;\n      if (this.deferStop) {\n        this.stop();\n      }\n    }\n  }\n  stop() {\n    if (activeEffect === this) {\n      this.deferStop = true;\n    } else if (this.active) {\n      cleanupEffect(this);\n      if (this.onStop) {\n        this.onStop();\n      }\n      this.active = false;\n    }\n  }\n}\nfunction cleanupEffect(effect2) {\n  const { deps } = effect2;\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect2);\n    }\n    deps.length = 0;\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn);\n  if (options) {\n    extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep());\n    }\n    const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { effect: activeEffect, target, type, key } : void 0;\n    trackEffects(dep, eventInfo);\n  }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack2 = false;\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit;\n      shouldTrack2 = !wasTracked(dep);\n    }\n  } else {\n    shouldTrack2 = !dep.has(activeEffect);\n  }\n  if (shouldTrack2) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n    if (!!(process.env.NODE_ENV !== \"production\") && activeEffect.onTrack) {\n      activeEffect.onTrack(\n        extend(\n          {\n            effect: activeEffect\n          },\n          debuggerEventExtraInfo\n        )\n      );\n    }\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  const eventInfo = !!(process.env.NODE_ENV !== \"production\") ? { target, type, key, newValue, oldValue, oldTarget } : void 0;\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  const effects = isArray(dep) ? dep : [...dep];\n  for (const effect2 of effects) {\n    if (effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n  for (const effect2 of effects) {\n    if (!effect2.computed) {\n      triggerEffect(effect2, debuggerEventExtraInfo);\n    }\n  }\n}\nfunction triggerEffect(effect2, debuggerEventExtraInfo) {\n  if (effect2 !== activeEffect || effect2.allowRecurse) {\n    if (!!(process.env.NODE_ENV !== \"production\") && effect2.onTrigger) {\n      effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n    if (effect2.scheduler) {\n      effect2.scheduler();\n    } else {\n      effect2.run();\n    }\n  }\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst get$1 = /* @__PURE__ */ createGetter();\nconst shallowGet = /* @__PURE__ */ createGetter(false, true);\nconst readonlyGet = /* @__PURE__ */ createGetter(true);\nconst shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly2 = false, shallow = false) {\n  return function get2(target, key, receiver) {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  };\n}\nconst set$1 = /* @__PURE__ */ createSetter();\nconst shallowSet = /* @__PURE__ */ createSetter(true);\nfunction createSetter(shallow = false) {\n  return function set2(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false;\n    }\n    if (!shallow) {\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  };\n}\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result && hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction has$1(target, key) {\n  const result = Reflect.has(target, key);\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\", key);\n  }\n  return result;\n}\nfunction ownKeys(target) {\n  track(target, \"iterate\", isArray(target) ? \"length\" : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n  get: get$1,\n  set: set$1,\n  deleteProperty,\n  has: has$1,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  },\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n};\nconst shallowReactiveHandlers = /* @__PURE__ */ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (key !== rawKey) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      false\n    );\n    readonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      false\n    );\n    shallowInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      true\n    );\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  def(value, \"__v_skip\", true);\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref2) {\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      trackEffects(ref2.dep || (ref2.dep = createDep()), {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      });\n    } else {\n      trackEffects(ref2.dep || (ref2.dep = createDep()));\n    }\n  }\n}\nfunction triggerRefValue(ref2, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      triggerEffects(dep, {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(dep);\n    }\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(\n    source,\n    key,\n    defaultValue\n  );\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this._dirty = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    trackRefValue(self);\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      console.warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nconst tick = /* @__PURE__ */ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n  queue.push(fn);\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue.length = 0;\n  queued = false;\n};\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = void 0;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n            scheduled = false;\n          });\n        }\n        for (const e of this.dep) {\n          if (e.computed instanceof DeferredComputedRefImpl) {\n            e.scheduler(\n              true\n              /* computedTrigger */\n            );\n          }\n        }\n      }\n      this._dirty = true;\n    });\n    this.effect.computed = this;\n  }\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n    return this._value;\n  }\n  get value() {\n    trackRefValue(this);\n    return toRaw(this)._get();\n  }\n}\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}