{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"C:/laragon/www/vue-projects/bookstore/node_modules/@babel/runtime/helpers/interopRequireDefault.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = inspectTypedArray;\nvar _getFuncName = _interopRequireDefault(require(\"get-func-name\"));\nvar _helpers = require(\"./helpers\");\nconst getArrayName = array => {\n  // We need to special case Node.js' Buffers, which report to be Uint8Array\n  if (typeof Buffer === 'function' && array instanceof Buffer) {\n    return 'Buffer';\n  }\n  if (array[Symbol.toStringTag]) {\n    return array[Symbol.toStringTag];\n  }\n  return (0, _getFuncName.default)(array.constructor);\n};\nfunction inspectTypedArray(array, options) {\n  const name = getArrayName(array);\n  options.truncate -= name.length + 4;\n  // Object.keys will always output the Array indices first, so we can slice by\n  // `array.length` to get non-index properties\n  const nonIndexProperties = Object.keys(array).slice(array.length);\n  if (!array.length && !nonIndexProperties.length) return `${name}[]`;\n  // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply\n  // stylise the toString() value of them\n  let output = '';\n  for (let i = 0; i < array.length; i++) {\n    const string = `${options.stylize((0, _helpers.truncate)(array[i], options.truncate), 'number')}${i === array.length - 1 ? '' : ', '}`;\n    options.truncate -= string.length;\n    if (array[i] !== array.length && options.truncate <= 3) {\n      output += `${_helpers.truncator}(${array.length - array[i] + 1})`;\n      break;\n    }\n    output += string;\n  }\n  let propertyContents = '';\n  if (nonIndexProperties.length) {\n    propertyContents = (0, _helpers.inspectList)(nonIndexProperties.map(key => [key, array[key]]), options, _helpers.inspectProperty);\n  }\n  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`;\n}","map":{"version":3,"names":["_getFuncName","_interopRequireDefault","require","_helpers","getArrayName","array","Buffer","Symbol","toStringTag","getFuncName","constructor","inspectTypedArray","options","name","truncate","length","nonIndexProperties","Object","keys","slice","output","i","string","stylize","truncator","propertyContents","inspectList","map","key","inspectProperty"],"sources":["C:/laragon/www/vue-projects/bookstore/node_modules/loupe/lib/typedarray.js"],"sourcesContent":["import getFuncName from 'get-func-name'\nimport { truncator, truncate, inspectProperty, inspectList } from './helpers'\n\nconst getArrayName = array => {\n  // We need to special case Node.js' Buffers, which report to be Uint8Array\n  if (typeof Buffer === 'function' && array instanceof Buffer) {\n    return 'Buffer'\n  }\n  if (array[Symbol.toStringTag]) {\n    return array[Symbol.toStringTag]\n  }\n  return getFuncName(array.constructor)\n}\n\nexport default function inspectTypedArray(array, options) {\n  const name = getArrayName(array)\n  options.truncate -= name.length + 4\n  // Object.keys will always output the Array indices first, so we can slice by\n  // `array.length` to get non-index properties\n  const nonIndexProperties = Object.keys(array).slice(array.length)\n  if (!array.length && !nonIndexProperties.length) return `${name}[]`\n  // As we know TypedArrays only contain Unsigned Integers, we can skip inspecting each one and simply\n  // stylise the toString() value of them\n  let output = ''\n  for (let i = 0; i < array.length; i++) {\n    const string = `${options.stylize(truncate(array[i], options.truncate), 'number')}${\n      i === array.length - 1 ? '' : ', '\n    }`\n    options.truncate -= string.length\n    if (array[i] !== array.length && options.truncate <= 3) {\n      output += `${truncator}(${array.length - array[i] + 1})`\n      break\n    }\n    output += string\n  }\n  let propertyContents = ''\n  if (nonIndexProperties.length) {\n    propertyContents = inspectList(\n      nonIndexProperties.map(key => [key, array[key]]),\n      options,\n      inspectProperty\n    )\n  }\n  return `${name}[ ${output}${propertyContents ? `, ${propertyContents}` : ''} ]`\n}\n"],"mappings":";;;;;;;AAAA,IAAAA,YAAA,GAAAC,sBAAA,CAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAEA,MAAME,YAAY,GAAGC,KAAK,IAAI;EAC5B;EACA,IAAI,OAAOC,MAAM,KAAK,UAAU,IAAID,KAAK,YAAYC,MAAM,EAAE;IAC3D,OAAO,QAAQ;EACjB;EACA,IAAID,KAAK,CAACE,MAAM,CAACC,WAAW,CAAC,EAAE;IAC7B,OAAOH,KAAK,CAACE,MAAM,CAACC,WAAW,CAAC;EAClC;EACA,OAAO,IAAAC,oBAAW,EAACJ,KAAK,CAACK,WAAW,CAAC;AACvC,CAAC;AAEc,SAASC,iBAAiBA,CAACN,KAAK,EAAEO,OAAO,EAAE;EACxD,MAAMC,IAAI,GAAGT,YAAY,CAACC,KAAK,CAAC;EAChCO,OAAO,CAACE,QAAQ,IAAID,IAAI,CAACE,MAAM,GAAG,CAAC;EACnC;EACA;EACA,MAAMC,kBAAkB,GAAGC,MAAM,CAACC,IAAI,CAACb,KAAK,CAAC,CAACc,KAAK,CAACd,KAAK,CAACU,MAAM,CAAC;EACjE,IAAI,CAACV,KAAK,CAACU,MAAM,IAAI,CAACC,kBAAkB,CAACD,MAAM,EAAE,OAAQ,GAAEF,IAAK,IAAG;EACnE;EACA;EACA,IAAIO,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGhB,KAAK,CAACU,MAAM,EAAEM,CAAC,EAAE,EAAE;IACrC,MAAMC,MAAM,GAAI,GAAEV,OAAO,CAACW,OAAO,CAAC,IAAAT,iBAAQ,EAACT,KAAK,CAACgB,CAAC,CAAC,EAAET,OAAO,CAACE,QAAQ,CAAC,EAAE,QAAQ,CAAE,GAChFO,CAAC,KAAKhB,KAAK,CAACU,MAAM,GAAG,CAAC,GAAG,EAAE,GAAG,IAC/B,EAAC;IACFH,OAAO,CAACE,QAAQ,IAAIQ,MAAM,CAACP,MAAM;IACjC,IAAIV,KAAK,CAACgB,CAAC,CAAC,KAAKhB,KAAK,CAACU,MAAM,IAAIH,OAAO,CAACE,QAAQ,IAAI,CAAC,EAAE;MACtDM,MAAM,IAAK,GAAEI,kBAAU,IAAGnB,KAAK,CAACU,MAAM,GAAGV,KAAK,CAACgB,CAAC,CAAC,GAAG,CAAE,GAAE;MACxD;IACF;IACAD,MAAM,IAAIE,MAAM;EAClB;EACA,IAAIG,gBAAgB,GAAG,EAAE;EACzB,IAAIT,kBAAkB,CAACD,MAAM,EAAE;IAC7BU,gBAAgB,GAAG,IAAAC,oBAAW,EAC5BV,kBAAkB,CAACW,GAAG,CAACC,GAAG,IAAI,CAACA,GAAG,EAAEvB,KAAK,CAACuB,GAAG,CAAC,CAAC,CAAC,EAChDhB,OAAO,EACPiB,wBACF,CAAC;EACH;EACA,OAAQ,GAAEhB,IAAK,KAAIO,MAAO,GAAEK,gBAAgB,GAAI,KAAIA,gBAAiB,EAAC,GAAG,EAAG,IAAG;AACjF"},"metadata":{},"sourceType":"script","externalDependencies":[]}